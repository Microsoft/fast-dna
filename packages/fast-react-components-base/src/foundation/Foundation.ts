import * as React from "react";
import * as ReactDOM from "react-dom";
import { set, get, pick, has, isPlainObject } from "lodash-es";

export interface IUnhandledProps {
    [key: string]: any;
}


export interface IReferenceResolverStore {
    [key: string]: IReferenceResolverStore | ReferenceResolver;
}

export interface IReferenceStore {
    [key: string]: React.ReactNode;
}

/**
 * Typing for a ref callback
 */
export type ReferenceResolver = <T>(reference: T) => void;

class Foundation<P, S> extends React.Component<P, S> {
    /**
     * default props for the component
     */
    public static defaultProps: object;


    protected referenceResolvers: IReferenceResolverStore = {};

    /**
     * Stores ref elements themselves.
     * @name references
     * @type {object}
     */
    protected referenceStore: IReferenceStore = {};

    /**
     * Stores a react ref callback under the path provided as arguments. Paths are resolved using lodash's get/set API.
     * The reference object itself will be stored on the referenceStore under the path provided and can be accessed via 
     * the getRef method under the same path.
     */
    protected setRef(...args: (string | number)[]): ReferenceResolver {
        const storageKey: string = this.processStorageKey(args);
        let resolverFunction: ReferenceResolver | IReferenceResolverStore = get(this.referenceResolvers, storageKey);

        if (!storageKey || isPlainObject(resolverFunction) || Array.isArray(resolverFunction)) {
            return;
        }
        
        if (typeof resolverFunction === "function") {
            return resolverFunction;
        } else {
            resolverFunction = (ref) => {
                set(this.referenceStore, storageKey, ref);
            }

            set(this.referenceResolvers, storageKey, resolverFunction);

            return resolverFunction;
        }
    }


    /**
     * gets a reference stored by the baseclass by keyname, where arguments are
     * used as keynames, eg getRef('foo', 'bar', 0) resolves to this.references.foo.bar[0];
     * @param args {(string|number)[]}
     */
    protected getRef(...args: (string | number)[]): React.ReactNode {
        return get(this.referenceStore, this.processStorageKey(args));
    }

    /**
     * Gets all props that aren't handled by the component.
     * @return {object} - an object containing all properties of 'props' that are not found on defaultProps
     */
    protected unhandledProps(): IUnhandledProps {
        const defaultPropsKey: string = "defaultProps";
        const defaultProps: object = this.constructor[defaultPropsKey];

        if (!defaultProps) {
            return this.props;
        }

        return pick(this.props, Object.keys(this.props).filter((key: any) => {
            return !has(defaultProps, key);
        }));
    }

    /**
     * Concatenates a component's generated className string with any additional classNames passed as props.
     * @param {string} componentClasses the HTML class attribute string generated by the component
     */
    protected generateClassNames(componentClasses?: string): string {
        const hasComponentClasses: boolean = typeof componentClasses === "string";
        const classKey: string = "className";

        if (!has(this.props, classKey)) {
            return hasComponentClasses ? componentClasses : null;
        }

        if (!hasComponentClasses) {
            return this.props[classKey];
        }

        return componentClasses.concat(` ${this.props[classKey]}`).trim().replace(/(\s){2,}/g, " ");
    }

    /**
     * Generates a string that conforms to object/array accessor syntax that can be used by lodash's get / set,
     * eg. => ["foo", "bar", 0] => "foo[bar][0]"
     */
    private processStorageKey(args: (string | number)[]): string {
        return args.filter(item => {
            return typeof item === "string" || typeof item === "number";
        }).map((item, index) => {
                return index === 0 ? item : `[${item}]`;
        }).join("");
    }
}

export default Foundation;
